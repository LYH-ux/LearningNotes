---
typora-root-url: OS_figure
typora-copy-images-to: OS_figure
---

`说明：本文属文章摘录总结。原文源于Java建设者 ，作者cxuan。阅于码农有道公众号。`

# 操作系统

### 1.基本结构

![image-20200717191554047](/image-20200717191554047.png)

`总线(Buses)`：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 `字(word)`。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）

处理器的核心大小为**一个字**的存储设备（或寄存器），称为`程序计数器(PC)`。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）

CPU 可能执行简单操作的几个步骤

- `加载(Load)`：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容
- `存储(Store)`：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容
- `操作(Operate)`：把两个寄存器的内容复制到 `ALU(Arithmetic logic unit)`。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。

> ❝
>
> 算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。
>
> ❞

- `跳转(jump)`：从指令中抽取一个字，把这个字复制到`程序计数器(PC)` 中，覆盖原来的值

### 2.进程和线程

- 进程的创建
  - 系统初始化（init）：启动操作系统时，通常会创建若干个进程。
  - 正在运行的程序执行了创建进程的系统调用（比如 fork）
  - 用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。
  - 初始化一个批处理工作

在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 `fork`。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的`内存映像`，相同的环境字符串和相同的打开文件

在 Windows 中，情况正相反，一个简单的 Win32 功能调用 `CreateProcess`，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。**「在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的」**

- 进程的终止
  - `正常退出(自愿的)` ：多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 `exit` ，在 Windows 中是 `ExitProcess`。
  - `错误退出(自愿的)`：比如执行一条不存在的命令，于是编译器就会提醒并退出。
  - `严重错误(非自愿的)`
  - `被其他进程杀死(非自愿的)` ：某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 `TerminateProcess`（注意不是系统调用）

- 进程的层次结构

  - UNIX 进程体系

    ![image-20200717192541238](/image-20200717192541238.png)

  整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。在 UNIX 中，进程不能剥夺其子进程的 `进程权`

  - WINDOWS 进程体系

    Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。

- 进程状态

  ![image-20200717193120284](/image-20200717193120284.png)

- 进程的实现

  操作系统为了执行进程间的切换，会维护着一张表，这张表就是 `进程表(process table)`。

  也叫PCB( process control table)

  每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息

  **每个进程都有一个地址空间**和一个控制线程

![image-20200717193331122](/image-20200717193331122.png)

与每一 I/O 类相关联的是一个称作 `中断向量(interrupt vector)` 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。

假设当一个磁盘中断发生时，用户进程 3 正在运行，则**中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈**，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。

当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，**会使某些进程就绪**，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程

1. 硬件压入堆栈程序计数器等
2. 硬件从中断向量装入新的程序计数器
3. 汇编语言过程保存寄存器的值
4. 汇编语言过程设置新的堆栈
5. C 中断服务器运行（典型的读和缓存写入）
6. 调度器决定下面哪个程序先运行
7. C 过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程

- 线程
  - 多线程之间会**共享同一块地址空间和所有可用数据**的能力，这是进程所不具备的
  - 线程要比进程`更轻量级`，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。
  - 第三个原因可能是性能方面的探讨，**如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强**，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度
  - 线程会有**程序计数器，用来记录接着要执行哪一条指令**；线程实际上 CPU 上调度执行的实体。

![image-20200717194954836](/image-20200717194954836.png)

一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，**「因此一个线程可以读取、写入甚至擦除另一个线程的堆栈」**

![image-20200717195144251](/image-20200717195144251.png)

每个线程都会有自己的堆栈，如下图所示

![image-20200717195218739](/image-20200717195218739.png)

- 线程系统调用

  进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 `thread_create`）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。

  当一个线程完成工作后，可以通过调用一个函数（比如 `thread_exit`）来退出。紧接着线程消失，状态变为终止，不能再进行调度

  另一个常见的线程是调用 `thread_yield`，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的

- POSIX(可移植操作系统接口)线程  

  `POSIX 线程 通常称为 pthreads`是一种独立于语言而存在的执行模型，以及并行执行模型

  POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如**「FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris」**，它在现有 Windows API 之上实现了**「pthread」**。

  | 线程调用             | 描述                           |
  | :------------------- | :----------------------------- |
  | pthread_create       | 创建一个新线程                 |
  | pthread_exit         | 结束调用的线程                 |
  | pthread_join         | 等待一个特定的线程退出         |
  | pthread_yield        | 释放 CPU 来运行另外一个线程    |
  | pthread_attr_init    | 创建并初始化一个线程的属性结构 |
  | pthread_attr_destory | 删除一个线程的属性结构         |

-  线程实现

  - 在用户空间中实现线程；

    内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构

    ![image-20200717213205971](/image-20200717213205971.png)

    线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程：pthread_create, pthread_exit, pthread_join 和 pthread_yield

  - 在内核空间中实现线程；

    进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作

    ![image-20200717213349339](/image-20200717213349339.png)

    内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。

    所有能够阻塞的调用都会通过系统调用的方式来实现，**当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止**

  - 在用户和内核空间中混合实现线程。

    ![image-20200717232206700](/image-20200717232206700.png)

  采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。

### 3.进程间通信

![image-20200717232306792](/image-20200717232306792.png)

- 信号

  通过向一个或多个进程发送`异步事件信号`来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。

  你可以在 Linux 系统上输入 `kill -l` 来列出系统使用的信号

  ![image-20200717232421204](/image-20200717232421204.png)

  进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：`SIGSTOP` 和 `SIGKILL` 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。

  操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。

- 管道pipe

  在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的`管线 pipelines` 就是用管道实现的，当 shell 发现输出  

  sort <f **|** head

  它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据

  ![image-20200717232723968](/image-20200717232723968.png)

  管道实际上就是 `|`，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的

- 共享内存 shared memory

  ![image-20200717232836288](/image-20200717232836288.png)

  在使用共享内存前，需要经过一系列的调用流程，流程如下

  - 创建共享内存段或者使用已创建的共享内存段`(shmget())`
  - 将进程附加到已经创建的内存段中`(shmat())`
  - 从已连接的共享内存段分离进程`(shmdt())`
  - 对共享内存段执行控制操作`(shmctl())`

- 先入先出队列FIFO/命名管道

  先入先出队列 FIFO 通常被称为 `命名管道(Named Pipes)`，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，**命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为**

- 消息队列message queue 

  消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。**每个消息队列由 IPC 标识符唯一标识**。消息队列有两种模式，一种是`严格模式`， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 `非严格模式`，消息的顺序性不是非常重要

- 套接字socket 

  socket 提供端到端的双向通信。一个套接字可以与一个或多个进程关联。就像管道有命名管道和未命名管道一样，套接字也有两种模式，**套接字一般用于两个进程之间的网络通信**，网络套接字需要来自诸如`TCP（传输控制协议）`或较低级别`UDP（用户数据报协议）`等基础协议的支持

  套接字有以下几种分类

  - `顺序包套接字(Sequential Packet Socket)`：此类套接字为**最大长度固定的数据报**提供可靠的连接。此连接是双向的并且是顺序的。
  - `数据报套接字(Datagram Socket)`：数据报套接字支持双向数据流。数据报套接字接受消息的顺序与发送者可能不同。
  - `流式套接字(Stream Socket)`：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。
  - `原始套接字(Raw Socket)`：可以使用原始套接字访问基础通信协议

### 4.进程调度

- `批处理(Batch)` : 商业领域

  - #### 先来先服务

  最简单的非抢占式调度算法的设计就是 `先来先服务(first-come,first-serverd)`。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。**当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后**

  在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。

  - #### 最短作业优先

  批处理中，第二种调度算法是 `最短作业优先(Shortest Job First)`，我们假设运行时间已知。例当输入队列中有若干个**同等重要的作业**被启动时，调度程序应使用最短优先作业算法

  **在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。**

  - #### 最短剩余时间优先

  最短作业优先的抢占式版本被称作为 `最短剩余时间优先(Shortest Remaining Time Next)` 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。

- `交互式(Interactive)`：交互式用户环境

  - #### 轮询调度

  每个进程都会被分配一个时间段，称为`时间片(quantum)`，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，当一个进程用完时间片后就被移到队列的末尾

  - #### 优先级调度

  轮询调度假设了所有的进程是同等重要的。优先级调度(priority scheduling)的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。

  - #### 多级队列

  最早使用优先级调度的系统是 `CTSS(Compatible TimeSharing System)`。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。

  - #### 最短进程优先

  最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 `T0`，现在假设测量到其下一次运行时间为 `T1`，可以用两个值的加权来改进估计时间，即`aT0+ (1- 1)T1`。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列

  ![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdXlPc9jU85pV5kdSicQXs4vElsDZyEhOEGc7kloCicKibhicT1j9OdpvSrebNliaPFjVMw67a9QmgJy3PQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。

  - #### 保证调度

  一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。

  - #### 彩票调度

  对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 `彩票调度(lottery scheduling)`算法。

  其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。

  - #### 公平分享调度

  到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。

  为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。

  ![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdXlPc9jU85pV5kdSicQXs4vEcf8F1AETmJ8BG7SDeAP0MyGgKX70KM3FTLO0um1cceyRkzuKibE0Mibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- `实时(Real time)`

实时系统可以分为两类，`硬实时(hard real time)` 和 `软实时(soft real time)` 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。

实时系统中的事件可以按照响应方式进一步分类为`周期性(以规则的时间间隔发生)`事件或 `非周期性(发生时间不可预知)`事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdXlPc9jU85pV5kdSicQXs4vEovUT9x68jPjlnftN3Vibn87VurHkT6w0lFnpvg1ntl7CjqKxeic1ZswQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

只有满足这个条件的实时系统称为`可调度的`，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。

### 5.内存管理

![image-20200717234911047](/image-20200717234911047.png)

- 地址空间

  - 动态重定位技术：通过简单方式将每个进程的地址空间映射到物理内存的不同区域。

  - 基址寄存器+变址寄存器。

    - 基址寄存器：存储数据内存的起始位置
    - 变址寄存器：存储应用程序的长度。

    每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将`基址值`添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于`变址寄存器` 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。

- 交换技术

  - 虚拟内存。  交换的过程中需要重定位。

- 虚拟内存

  虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为`页面(page)`的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。***（缺页异常）***

  程序生成的地址被称为 `虚拟地址(virtual addresses)` 并形成`虚拟地址空间(virtual address space)`，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。**「在使用虚拟内存时，虚拟地址不会直接发送到内存总线上」**。相反，会使用 `MMU(Memory Management Unit)` 内存管理单元把**「虚拟地址映射为物理内存地址」**

  - 分段

  - 分页

    ![image-20200718064312983](/image-20200718064312983.png)

    `修改位(Modified)` 和 `访问位(Referenced)` 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 `脏` 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 `干净`的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 `脏位(dirty bit)`，因为它反映了页面的状态。

    `访问位(Referenced)` 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。

  - 段页式

  - 页面置换算法

    ### 最近未使用页面置换算法

    为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。**「每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M」**，这些位包含在每个页表项中，就像下面所示

    ![image-20200718064312983](/image-20200718064312983.png)

    因为每次访问时都会更新这些位，因此由`硬件`来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。

    如果硬件没有这些位，那么可以使用操作系统的`缺页中断`和`时钟中断`机制来进行模拟。当启动一个进程时，将其所有的页面都标记为`不在内存`；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 `R 位(在它的内部表中)`，修改页表项使其指向正确的页面，并设置为 `READ ONLY` 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 `READ/WRITE`。

    可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。**R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。**

    当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：

    - 第 0 类：没有引用 R，没有修改 M
    - 第 1 类：没有引用 R，已修改 M
    - 第 2 类：引用 R ，没有修改 M
    - 第 3 类：已被访问 R，已被修改 M

    尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。

    `NRU(Not Recently Used)` 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是**「易于理解并且能够有效的实现」**。

    ### 时钟页面置换算法

    一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示

    ![image-20200718071206329](/image-20200718071206329.png)

    当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 `时钟(clokc)`算法了。

    ### 最近最少使用页面置换算法

    在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 `LRU(Least Recently Used)` ，最近最少使用页面置换算法。

    虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用`硬件`来实现也是一样的费时。

    ### 用软件模拟 LRU

    尽管上面的 LRU 算法在原则上是可以实现的，**「但是很少有机器能够拥有那些特殊的硬件」**。上面是硬件的实现方式，那么现在考虑要用`软件`来实现 LRU 。一种可以实现的方案是 `NFU(Not Frequently Used，最不常用)`算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。

    只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤

    - 首先，在 R 位被添加进来之前先把计数器右移一位；
    - 第二步，R 位被添加到最左边的位而不是最右边的位。

    修改以后的算法称为 `老化(aging)` 算法，下图解释了老化算法是如何工作的。

    ![image-20200718071145034](/image-20200718071145034.png)

    我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，**「在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了」**，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 `左侧` ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。

    > ❝
    >
    > CPU正在以某个频率前进，该频率的周期称为`时钟滴答`或`时钟周期`。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。
    >
    > ❞

    当缺页异常出现时，将**`置换（就是移除）`计数器值最小的页面**。**如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。**

    这个算法与 LRU 算法有两个重要的区别：看一下上图中的 `e`，第三列和第五列

    ![image-20200718071120773](/image-20200718071120773.png)

    | 算法                  | 注释                     |
    | :-------------------- | :----------------------- |
    | 最优算法              | 不可实现，但可以用作基准 |
    | NRU(最近未使用) 算法  | 和 LRU 算法很相似        |
    | FIFO(先进先出) 算法   | 有可能会抛弃重要的页面   |
    | 第二次机会算法        | 比 FIFO 有较大的改善     |
    | 时钟算法              | 实际使用                 |
    | LRU(最近最少)算法     | 比较优秀，但是很难实现   |
    | NFU(最不经常使用)算法 | 和 LRU 很类似            |
    | 老化算法              | 近似 LRU 的高效算法      |
    | 工作集算法            | 实施起来开销很大         |
    | 工作集时钟算法        | 比较有效的算法           |

    **「最好的算法是老化算法和WSClock算法」**。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现

- 空闲内存管理

  - `位图(bitmap)`

    每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）

    ![image-20200718063042440](/image-20200718063042440.png)

    `位图`提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为**「位图的大小取决于内存和分配单元的大小」**。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，`内容管理器(memory manager)` **必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点**。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）

  - `空闲列表(free lists)`

    维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。链表中的每一项都可以代表一个 `空闲区(H)` 或者是`进程(P)`的起始标志，长度和下一个链表项的位置。

    ![image-20200718063619143](/image-20200718063619143.png)

    有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 `首次适配(first fit)`。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。

    首次适配的一个小的变体是 `下次适配(next fit)`。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。

    另外一个著名的并且广泛使用的算法是 `最佳适配(best fit)`。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。

### 6.文件系统

在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。

- 文件结构

  ![image-20200718072035027](/image-20200718072035027.png)

  a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，**操作系统能看到的就是`字节(bytes)`。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。**

  图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。把文件作为记录序列的核心思想是：**「读操作返回一个记录，而写操作重写或者追加一个记录」**。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗`记录树`构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个`key` 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。

- 文件类型

  UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有`字符特殊文件(character special file)` 和 `块特殊文件(block special file)`。`常规文件(Regular files)` 是包含有用户信息的文件。

- 文件访问

  有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 `read` 从头开始读取。另一种是用一个特殊的 `seek` 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows  使用的是后面一种方式。

- 文件操作
  1. `Create`，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。
  2. `Delete`，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。
  3. `Open`，**在使用文件之前，必须先打开文件**。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。
  4. `Close`，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一`块`，即使这个块空间内部还不满。
  5. `Read`，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。
  6. `Write`，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。
  7. `append`，使用 append 只能向文件末尾添加数据。
  8. `seek`，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 **seek 系统调用把当前位置指针指向文件中的特定位置**。seek 调用结束后，就可以从指定位置开始读写数据了。
  9. `get attributes`，进程运行时通常需要读取文件属性。
  10. `set attributes`，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。
  11. `rename`，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。

- 目录

  `层次目录系统(Hierarchical Directory Systems)`，也称为`目录树`。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下

  ![image-20200718072743176](/image-20200718072743176.png)

  根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户各自创建了`子目录`

  - 路径名

    每个文件都会用一个`绝对路径名(absolute path name)`，它由根目录到文件的路径组成。

    另外一种指定文件名的方法是 `相对路径名(relative path name)`。它常常和 `工作目录(working directory)` （也称作 `当前目录(current directory)`）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 `/usr/ast`，那么绝对路径 `/usr/ast/mailbox`可以直接使用 `mailbox` 来引用

  - 目录操作
    1. `Create`，创建目录，除了目录项 `.` 和 `..` 外，目录内容为空。
    2. `Delete`，**删除目录，只有空目录可以删除**。只包含 `.` 和 `..` 的目录被认为是空目录，这两个目录项通常不能删除
    3. `opendir`，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。
    4. `closedir`，读目录结束后，应该关闭目录用于释放内部表空间。
    5. `readdir`，系统调用 **readdir 返回打开目录的下一个目录项**。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，**readdir 总是以标准格式返回一个目录项。**
    6. `rename`，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。
    7. `link`，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为`硬链接(hard link)`。
    8. `unlink`，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。

- 文件系统的实现

  文件系统存储在`磁盘`中。大部分的磁盘能够划分出一到多个分区，叫做`磁盘分区(disk partitioning)` 或者是`磁盘分片(disk slicing)`。每个分区都有独立的文件系统，每块分区的文件系统可以不同。

  磁盘的 **0 号分区**称为 `主引导记录(Master Boot Record, MBR)`，用来`引导(boot)` 计算机。在 MBR 的结尾是`分区表(partition table)`。每个分区表给出每个分区由开始到结束的地址。

  BIOS 读入并执行 MBR

  ![image-20200718085933530](/image-20200718085933530.png)

  #### 引导块

  MBR 做的第一件事就是`确定活动分区`，读入它的第一个块，称为`引导块(boot block)` 并执行。**引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。**引导块占据文件系统的**前 4096 个字节，从磁盘上的字节偏移量 0 开始**。引导块可用于启动操作系统。

  ![image-20200718090110389](/image-20200718090110389.png)

  除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的

  ![image-20200718090504867](/image-20200718090504867.png)

  #### 超级块

  紧跟在引导块后面的是 `超级块(Superblock)`，超级块的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数

  - 文件系统的大小
  - 文件系统中的数据块数
  - 指示文件系统状态的标志
  - 分配组大小

  在计算机启动或者文件系统首次使用时，超级块会被读入内存。

  #### 空闲空间块

  接着是文件系统中`空闲块`的信息，例如，可以用位图或者指针列表的形式给出。

  **「BitMap 位图或者 Bit vector 位向量」**

  位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110

  ![image-20200718090652187](/image-20200718090652187.png)

  **「使用链表进行管理」**

  在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。

  ![image-20200718090730318](/image-20200718090730318.png)

  #### inode

  然后在后面是一个 `inode(index node)`，也称作索引节点。它是一个数组的结构，**每个文件有一个 inode**，inode 非常重要，它说明了文件的方方面面。**每个索引节点都存储对象数据的属性和磁盘块位置**

  有一种简单的方法可以找到它们 `ls -lai` 命令。让我们看一下根文件系统：

  inode 节点主要包括了以下信息

  - 模式/权限（保护）
  - 所有者 ID
  - 组 ID
  - 文件大小
  - 文件的硬链接数
  - 上次访问时间
  - 最后修改时间
  - inode 上次修改时间

  文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。

  紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。

- 文件的实现

  分配背后的主要思想是`有效利用文件空间`和`快速访问文件`

  - 连续分配

  - 链表分配

    ![image-20200718093258371](/image-20200718093258371.png)

    顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。

    还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完整的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了**查找和拼接的开销**

  - 索引分配

    使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中

    ![image-20200718093703686](/image-20200718093703686.png)

    两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 `文件分配表(File Application Table,FAT)`

- 共享文件

  ![image-20200718094017596](/image-20200718094017596.png)

 B 的目录与该共享文件的联系称为 `链接(link)`。那么文件系统现在就是一个 `有向无环图(Directed Acyclic Graph, 简称 DAG)`，而不是一棵树了

- 文件系统结构  `日志结构文件系统(Log-structured File System, LFS)`
  - 日志结构文件系统

    解决以下问题。

    - 不断增长的系统内存
    - 顺序 I/O 性能胜过随机 I/O 性能
    - 现有低效率的文件系统
    - 文件系统不支持 RAID（虚拟化）

  - 日志文件系统

    虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做`日志文件系统`，它会记录系统下一步将要做什么的日志。微软的 `NTFS` 文件系统、Linux 的 `ext3` 就使用了此日志。`OS X` 将日志系统作为可供选项。

  - 虚拟文件系统 VFS

    UNIX 操作系统使用一种 `虚拟文件系统(Virtual File System, VFS)` 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。

    ![image-20200719065901950](/image-20200719065901950.png)

    **在计算机世界中，任何解决不了的问题都可以加个`代理`来解决。**所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是**标准的 `POSIX 系统调用`，比如 open、read、write 和 seek 等**。VFS 对用户进程有一个 `上层` 接口，这个接口就是著名的 POSIX 接口。

- 文件系统的管理和优化

  - 磁盘空间管理

    **「分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块」**

    相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储

    - 块操作

      - 块大小

        如果分配的块`太大`会浪费`空间`；分配的块`太小`会浪费`时间`

      - 记录空闲块

        ![image-20200719070504064](/image-20200719070504064.png)

        采用`磁盘块链表`，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。

        另一种空闲空间管理的技术是`位图(bitmap)`，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，**和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位**。只有当磁盘快满的时候，链表需要的块才会比位图少

      - 磁盘配额

        为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种`磁盘配额(enforcing disk quotas)`的机制。系统管理员为每个用户分配**「最大的文件和块分配」**，并且操作系统确保用户不会超过其配额。

        在用户打开一个文件时，操作系统会找到`文件属性`和`磁盘地址`，并把它们送入内存中的打开文件表。其中一个属性告诉`文件所有者`是谁。任何有关文件的增加都会记到所有者的配额中。

        ![image-20200719071027445](/image-20200719071027445.png)

        当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加`硬限制`和`软限制`的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。

  - 文件系统备份

  - 文件系统一致性

    影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种`不一致(inconsistent)`的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。

    为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 `fsck`；Windows 有 `sfc`，每当引导系统时（尤其是在崩溃后），都可以运行该程序。

    可以进行两种一致性检查：**「块的一致性检查和文件的一致性检查」**。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。

  - 文件系统性能

    如果只访问一个字，内存要比磁盘快百万数量级

    #### 高速缓存

    最常用的减少磁盘访问次数的技术是使用 `块高速缓存(block cache)` 或者 `缓冲区高速缓存(buffer cache)`。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。

    #### 块提前读

    第二个明显提高文件系统的性能是，在需要用到块之前，试图`提前`将其写入高速缓存，从而`提高命中率`。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。

    当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。

    #### 减少磁盘臂运动

    高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是**「把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数」**。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的

    #### 磁盘碎片整理

    固态硬盘并不受磁盘碎片的影响

    磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理

### 7.IO设备

![image-20200719082411115](/image-20200719082411115.png)

- 块设备

  块设备是一个能存储`固定大小块`信息的设备，它支持**「以固定大小的块，扇区或群集读取和（可选）写入数据」**。每个块都有自己的`物理地址`。通常块的大小在 512 - 65536 之间。所有传输的信息都会以`连续`的块为单位

  常见的块设备有**「硬盘、蓝光光盘、USB 盘」**

  **块设备要求整块读写**

  要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备

- 字符设备

  字符设备以`字符`为单位发送或接收一个字符流，而不考虑任何块结构。**字符设备是不可寻址的，也没有任何寻道操作**。常见的字符设备有 **「打印机、网络设备、鼠标、以及大多数与磁盘不同的设备」**。

- 设备控制器

  设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些`特殊目的寄存器(special purpose registers)`也就是本地缓冲区中。

  **每个设备控制器都会有一个应用程序与之对应**，设备控制器通过应用程序的接口通过中断与操作系统进行通信。**设备控制器是硬件**，而设备驱动程序是软件。

- 内存映射I/O

  每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等

  为了控制`寄存器`，许多设备都会有`数据缓冲区(data buffer)`，来供系统进行读写

  - 每个控制寄存器都被分配一个 `I/O 端口(I/O port)`号，这是一个 8 位或 16 位的整数。**所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）**。使用特殊的 I/O 指令像是

    ```
    IN REG,PORT
    ```

    CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用

    ```
    OUT PORT,REG
    ```

    CPU 可以将 REG 的内容写到控制寄存器中。

  - PDP-11 引入的，它将**「所有控制寄存器映射到内存空间」**中。

- 直接内存访问DMA

  无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器**每次请求一个字节的数据，但是这么做会浪费 CPU 时间**，所以经常会用到一种称为`直接内存访问(Direct Memory Access)` 的方案。

  ![image-20200719085438064](/image-20200719085438064.png)

  CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。

  DMA 控制器通过在总线上发出一个`读请求`到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。

  DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。

- 中断

- I/O软件

  - 设备独立性

    **「我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备」**

    ![image-20200719085959477](/image-20200719085959477.png)

  - 错误处理

    通常情况下来说，错误应该交给`硬件`层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理

  - 同步和异步传输

    同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有`同步时钟`。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加`奇偶校验位`。大部分`物理IO(physical I/O)` 是异步的

  - 缓冲

    从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。

  - 共享和独占

    有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用

  - 三种控制方法： 轮询、中断、DMA

- I/O层次结构

  ![image-20200719090516181](/image-20200719090516181.png)

  - 中断

    通常会有三种通知方式，依赖于不同的具体实现

    - 信号量实现中：在信号量上使用 `up` 进行通知；
    - 管程实现：对管程中的条件变量执行 `signal` 操作
    - 还有一些情况是发送一些消息

  - 设备驱动

    设备驱动程序必须是`可重入`的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互

  - 设备管理层

    与设备无关的软件。对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口

    ![image-20200719090929850](/image-20200719090929850.png)

    - 错误处理

      I/O 错误的一类是程序员`编程`错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理

    - 为设备驱动程序提供统一接口，便于接入不同硬件和厂商的设备
    - 有些设备只能单进程使用，所以要管理访问顺序

- #### RAID

  RAID 称为 `磁盘冗余阵列`，简称 `磁盘阵列`。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余

- 磁盘格式化

![image-20200719091514602](/image-20200719091514602.png)

前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括`柱面号`、`扇区号`等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。**大部分磁盘使用 512 字节的扇区**。数据区后面是 ECC，ECC 的全称是 **「error correction code」** ，`数据纠错码`，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于**「设计者愿意牺牲多少磁盘空间来提高可靠性」**，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区

- 磁盘读写

  影响磁盘快读写的时间由下面几个因素决定

  - 寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间
  - 旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间
  - 实际数据的读取或者写入时间

  有效的降低寻道时间能够提高磁盘的读取速度。

  `最短路径优先(SSF)` 算法

  一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理

### 8.资源与死锁

- 可抢占资源和不可抢占资源

  `可抢占资源(preemptable resource)`可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。

  `不可抢占资源(nonpreemtable resource)` 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。

- 死锁：一组进程均占有某些资源，都在等待另一些进程占有的某些资源

  **「如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁」**

- 死锁形成

  资源死锁可能出现的情况主要有

  - 互斥条件：每个资源都被分配给了一个进程或者资源是可用的
  - 保持和等待条件：已经获取资源的进程被认为能够获取新的资源
  - 不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放
  - 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。

  发生死锁时，上面的情况**必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生**。可以通过破坏其中任意一个条件来破坏死锁

- 死锁解决

  - 如果频次低于其它故障，不理会
  - 检测和恢复。 死锁检测是基于向量的比较
  - 死锁避免
    - 银行家算法
    - 破坏死锁产生的四个条件
    - 两阶段加锁：实际应用中不通用

- 通信死锁

  进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生`死锁`

  可以使用通信中一个非常重要的概念来避免：`超时(timeout)`。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。

- 活锁

  两个进程分别尝试获取另一个锁失败后，会释放自己持有的锁，并再次尝试。这个过程一直重复

- 饥饿

  一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。

  