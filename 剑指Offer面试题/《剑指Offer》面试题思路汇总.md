# 《剑指Offer面试题》思路汇总

注：本系列专题为《剑指Offer》第2版的面试题解题思路汇总

另参见《剑指Offer面试题》实战解析篇

## 一、编程基础篇

### 1.C++类实现赋值运算符函数

1. 关注点

   - 返回值类型要声明为引用，函数结束返回自身的引用(*this)。这样可允许连续赋值

   - 传入的参数类型应声明为**常量引用**，避免形参到实参调用一次复制构造函数

     注：复制构造函数实现时也应该传常量引用。不允许传值参数。不然会递归进行复制构造而崩溃

   - 使用完毕要释放自身已有的内存
   - 要判断传入的参数和当前实例是否是同一个实例

2. 进阶实现

   - 未考虑异常安全性，先判断实例是否相同，释放实例内存，申请新内存复制传入的实例，返回引用

     此解法未考虑申请新内存失败的问题。若崩溃，则原有实例也被破坏

   - 考虑异常安全性，Copy on delete。先创建一个临时实例，再交换临时实例和原来的实例。而当函数返回时，临时实例出了作用域，会自动调用析构函数释放内存。

     如果创建临时实例失败后抛异常，原有实例并未被改变

### 2.单例模式

1. 几种解法分析

   - 只适用于单线程环境，构造函数私有，提供公有方法访问和创建实例。只判实例是否存在，未加锁。在多线程环境下会出错。

   - 先加锁，然后判断实例是否存在。 本解法每次访问实例时均会加锁。 开销大，效率不高。

   - 双重锁定，加锁前后两次判断实例是否存在。第一次判断减少直接上锁的开销。第二次判断不可少！当两个线程同时通过第一重判断时，加锁保证了只有一个线程能访问。而第二次判断保证了当先入线程创建实例并退出后，其它线程获取锁后不会再进行操作。

     上述三种方式均属于懒汉时单例，在第一次引用时才会实例化。

   - 构造函数私有化。在初始化静态变量的时候创建一个实例。但这个创建实例的时机不由程序员所掌控。会过早实例化。

   - 内部定义一个嵌套类，用第四种方法实现静态变量构造实例。 类外静态函数接口通过调用该私有类的实例来创建实例。

## 二、数据结构篇

### 1.基本用法

- 栈与递归相关，队列与广度优先遍历算法相关
- 数组具有O(1)的访问效率，可以用数组实现简单的哈希表：下标设为哈希表键值，对应的内存为值。这样可以实现O (1)的查找。
- c/c ++可以用指针访问数组。 但是没有记录数组大小，所以**用指针访问数组元素时要确保没有越界。**

- 当数组作为函数的参数进行传递时，数组会自动退化为同类型的指针。所在在该函数内用sizeof时，求得的是指针的大小，而非数组的大小。

### 2.找出数组中重复的数字,长度为n，范围为0~n-1

1. 思路分析
   - 从头到尾扫描排序后的数组。排序一个长序为n的数组可实现为O(nlogn)。快排、归并排序、堆排序
   - 用哈希表，比如数组，或stl的unordered_map。时间复杂度O(n),空间复杂度O(n).
   - 从头扫描，元素归位，数字i放到下标为i的位置。比较过程中可发现重复数字，返回TRUE .看似有两重循环，实际每个数字最多交换两次。总的时间复杂度是O (n )。
   - 注意：实现过程要先判断输入的合法性。
2. 测试用例
   - 长度为n 的数组包含有重复数字
   - 数组中不包含重复数字
   - 无效输入测试用例（空指针，数组范围不正确）
3. 启发与迁移
   - 数组中利用下标定位元素。
   - 下标索引与相应内存可形成键值对，可建立查找表
   - 数组归位到按值索引：if (data [ data[i] ] == data [i])

### 3.不修改数组找出重复的数字

1. 题目说明：在长度为n+1的数组里，数字是1~n的范围，所以至少有一个数字是重复的。 找出任意一个重复的数字，但不能修改数组。

2. 思路分析

   - 创建一个长度为n+1的辅助数组， 以数字值m为下标索引复制到下标为m的为置。 可以发现重复数字。

   - 避免使用o（n）的辅助空间，可从某一个中间数字m ,将数组中的数字分为1~m和m+1~n两部分，统计该区间内数字个数，找出重复区间。 然后再二分查找逐步缩小范围。  

     这里的二分查找前多一步统计区间数字数目。

     O(nlogn) ，空间复杂度为O(1)  .  相当于以时间换空间了。

   - 要清楚需求。如找出任意一个，找出所有重复数字。 或时间效率优先，或空间效率优先。 在写代码之前要问清楚面试官需求。

3. 测试用例

   - 长度为n 的数组里包含一个或多个重复数字。
   - 不包含重复数字
   - 无效输入（空指针）

## 三、算法和数据操作

### 1.斐波那契数列

1. 解法

   - 递归，代码简洁，但效率低。而且有很多节点重复。
   - 迭代，从下往上计算，循环，O(n)复杂度。
   - 基于递归用o（log n）的时间求得n 次方的算法。

2. 延伸

   - 青蛙跳台阶问题，一次可跳一级或两级。 跳上n级的台阶共有多少种跳法

     f(n)=f(n -1)+f（n-2）,取决于它前一级或前两级有多少种跳法

   - 用2*1的小矩形去覆盖更大的矩形。 这仍然是斐波那契数列

3. 测试用例

   - 功能测试
   - 边界值测试,0 , 1, 2
   - 性能测试，输入较大的数字。

2.